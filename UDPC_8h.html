<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UDPConnection: src/UDPC.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UDPConnection
   </div>
   <div id="projectbrief">A network connection implementation over UDP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">UDPC.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Public API for UDPConnection.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;winsock2.h&gt;</code><br />
<code>#include &lt;Ws2ipdef.h&gt;</code><br />
<code>#include &lt;In6addr.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="UDPC_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data identifying a peer via addr, port, and scope_id.  <a href="structUDPC__ConnectionId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data representing a received/sent packet.  <a href="structUDPC__PacketInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUDPC__Event.html">UDPC_Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing information related to the type of event.  <a href="structUDPC__Event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionUDPC__Event_1_1Value.html">UDPC_Event::Value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8ed92f1223b3f658536728f22d3b3827"><td class="memItemLeft" align="right" valign="top"><a id="a8ed92f1223b3f658536728f22d3b3827" name="a8ed92f1223b3f658536728f22d3b3827"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_PACKET_MAX_SIZE</b>&#160;&#160;&#160;8192</td></tr>
<tr class="memdesc:a8ed92f1223b3f658536728f22d3b3827"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of a UDP packet. <br /></td></tr>
<tr class="separator:a8ed92f1223b3f658536728f22d3b3827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780462f48fb18ccb15545ad9d05c70df"><td class="memItemLeft" align="right" valign="top"><a id="a780462f48fb18ccb15545ad9d05c70df" name="a780462f48fb18ccb15545ad9d05c70df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_DEFAULT_PROTOCOL_ID</b>&#160;&#160;&#160;1357924680</td></tr>
<tr class="separator:a780462f48fb18ccb15545ad9d05c70df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6414a39d34be1f50a660ef89f01c800a"><td class="memItemLeft" align="right" valign="top"><a id="a6414a39d34be1f50a660ef89f01c800a" name="a6414a39d34be1f50a660ef89f01c800a"></a>
typedef struct UDPC_Context *&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_HContext</b></td></tr>
<tr class="separator:a6414a39d34be1f50a660ef89f01c800a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf09773dbd86360fc70149232bfd3e8e"><td class="memItemLeft" align="right" valign="top"><a id="acf09773dbd86360fc70149232bfd3e8e" name="acf09773dbd86360fc70149232bfd3e8e"></a>
typedef enum UDPC_EXPORT UDPC_LoggingType&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_LoggingType</b></td></tr>
<tr class="separator:acf09773dbd86360fc70149232bfd3e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228cd7ddf56a4e76e216bc3b80e8bd4a"><td class="memItemLeft" align="right" valign="top">typedef enum UDPC_EXPORT <a class="el" href="UDPC_8h.html#a228cd7ddf56a4e76e216bc3b80e8bd4a">UDPC_AuthPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a228cd7ddf56a4e76e216bc3b80e8bd4a">UDPC_AuthPolicy</a></td></tr>
<tr class="separator:a228cd7ddf56a4e76e216bc3b80e8bd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5afb11964c7a55edf34ddf9097779b2"><td class="memItemLeft" align="right" valign="top">typedef struct UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#ae5afb11964c7a55edf34ddf9097779b2">UDPC_ConnectionId</a></td></tr>
<tr class="memdesc:ae5afb11964c7a55edf34ddf9097779b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data identifying a peer via addr, port, and scope_id.  <a href="UDPC_8h.html#ae5afb11964c7a55edf34ddf9097779b2">More...</a><br /></td></tr>
<tr class="separator:ae5afb11964c7a55edf34ddf9097779b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0261958047ebb5c6a402aa805e4e55b"><td class="memItemLeft" align="right" valign="top">typedef struct UDPC_EXPORT <a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#ae0261958047ebb5c6a402aa805e4e55b">UDPC_PacketInfo</a></td></tr>
<tr class="memdesc:ae0261958047ebb5c6a402aa805e4e55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data representing a received/sent packet.  <a href="UDPC_8h.html#ae0261958047ebb5c6a402aa805e4e55b">More...</a><br /></td></tr>
<tr class="separator:ae0261958047ebb5c6a402aa805e4e55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa0534bf7f04bb2f6ce8975c99c4af0"><td class="memItemLeft" align="right" valign="top">typedef enum UDPC_EXPORT <a class="el" href="UDPC_8h.html#adaa0534bf7f04bb2f6ce8975c99c4af0">UDPC_EventType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#adaa0534bf7f04bb2f6ce8975c99c4af0">UDPC_EventType</a></td></tr>
<tr class="memdesc:adaa0534bf7f04bb2f6ce8975c99c4af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing the type of event.  <a href="UDPC_8h.html#adaa0534bf7f04bb2f6ce8975c99c4af0">More...</a><br /></td></tr>
<tr class="separator:adaa0534bf7f04bb2f6ce8975c99c4af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3215b65686670720f098eda2ca1eed"><td class="memItemLeft" align="right" valign="top">typedef struct UDPC_EXPORT <a class="el" href="structUDPC__Event.html">UDPC_Event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a7b3215b65686670720f098eda2ca1eed">UDPC_Event</a></td></tr>
<tr class="memdesc:a7b3215b65686670720f098eda2ca1eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing information related to the type of event.  <a href="UDPC_8h.html#a7b3215b65686670720f098eda2ca1eed">More...</a><br /></td></tr>
<tr class="separator:a7b3215b65686670720f098eda2ca1eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aea7e32ca9fdc04530f95c97459391e6d"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#aea7e32ca9fdc04530f95c97459391e6d">UDPC_create_id</a> (UDPC_IPV6_ADDR_TYPE addr, uint16_t port)</td></tr>
<tr class="memdesc:aea7e32ca9fdc04530f95c97459391e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> with the given addr and port.  <a href="UDPC_8h.html#aea7e32ca9fdc04530f95c97459391e6d">More...</a><br /></td></tr>
<tr class="separator:aea7e32ca9fdc04530f95c97459391e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cb345ce117c04017afd443e5748f19"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#ab7cb345ce117c04017afd443e5748f19">UDPC_create_id_full</a> (UDPC_IPV6_ADDR_TYPE addr, uint32_t scope_id, uint16_t port)</td></tr>
<tr class="memdesc:ab7cb345ce117c04017afd443e5748f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> with the given addr, scope_id, and port.  <a href="UDPC_8h.html#ab7cb345ce117c04017afd443e5748f19">More...</a><br /></td></tr>
<tr class="separator:ab7cb345ce117c04017afd443e5748f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa3e1e54877029a226ab9cfb74215df"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a0fa3e1e54877029a226ab9cfb74215df">UDPC_create_id_anyaddr</a> (uint16_t port)</td></tr>
<tr class="memdesc:a0fa3e1e54877029a226ab9cfb74215df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> with the given port.  <a href="UDPC_8h.html#a0fa3e1e54877029a226ab9cfb74215df">More...</a><br /></td></tr>
<tr class="separator:a0fa3e1e54877029a226ab9cfb74215df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b80d2df882f03aeee8a92bed7fb0131"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a8b80d2df882f03aeee8a92bed7fb0131">UDPC_create_id_easy</a> (const char *addrString, uint16_t port)</td></tr>
<tr class="memdesc:a8b80d2df882f03aeee8a92bed7fb0131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> with the given addr string and port.  <a href="UDPC_8h.html#a8b80d2df882f03aeee8a92bed7fb0131">More...</a><br /></td></tr>
<tr class="separator:a8b80d2df882f03aeee8a92bed7fb0131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a8258674d2445604499efc7c75462"><td class="memItemLeft" align="right" valign="top"><a id="a980a8258674d2445604499efc7c75462" name="a980a8258674d2445604499efc7c75462"></a>
UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_create_id_hostname</b> (const char *hostname, uint16_t port)</td></tr>
<tr class="separator:a980a8258674d2445604499efc7c75462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dee65fcd5b70d25abbf6d4a3ee59f2"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT UDPC_HContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2">UDPC_init</a> (<a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> listenId, int isClient, int isUsingLibsodium)</td></tr>
<tr class="memdesc:a89dee65fcd5b70d25abbf6d4a3ee59f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an UDPC_HContext that holds state for connections.  <a href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2">More...</a><br /></td></tr>
<tr class="separator:a89dee65fcd5b70d25abbf6d4a3ee59f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614e2a058b89839d53fe9d348a058323"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT UDPC_HContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a614e2a058b89839d53fe9d348a058323">UDPC_init_threaded_update</a> (<a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> listenId, int isClient, int isUsingLibsodium)</td></tr>
<tr class="memdesc:a614e2a058b89839d53fe9d348a058323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an UDPC_HContext that holds state for connections that auto-updates via a thread.  <a href="UDPC_8h.html#a614e2a058b89839d53fe9d348a058323">More...</a><br /></td></tr>
<tr class="separator:a614e2a058b89839d53fe9d348a058323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a5258877ad3084f7d29954be525bd6"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT UDPC_HContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#ab9a5258877ad3084f7d29954be525bd6">UDPC_init_threaded_update_ms</a> (<a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> listenId, int isClient, int updateMS, int isUsingLibsodium)</td></tr>
<tr class="memdesc:ab9a5258877ad3084f7d29954be525bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an UDPC_HContext that holds state for connections that auto-updates via a thread at a specified interval.  <a href="UDPC_8h.html#ab9a5258877ad3084f7d29954be525bd6">More...</a><br /></td></tr>
<tr class="separator:ab9a5258877ad3084f7d29954be525bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fafce547e9185c29f42d06213b0ff4f"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a0fafce547e9185c29f42d06213b0ff4f">UDPC_enable_threaded_update</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:a0fafce547e9185c29f42d06213b0ff4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables auto updating on a separate thread for the given UDPC_HContext.  <a href="UDPC_8h.html#a0fafce547e9185c29f42d06213b0ff4f">More...</a><br /></td></tr>
<tr class="separator:a0fafce547e9185c29f42d06213b0ff4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a50763773d55aa7a2a9c7ad69575833"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a1a50763773d55aa7a2a9c7ad69575833">UDPC_enable_threaded_update_ms</a> (UDPC_HContext ctx, int updateMS)</td></tr>
<tr class="memdesc:a1a50763773d55aa7a2a9c7ad69575833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables auto updating on a separate thread for the given UDPC_HContext with the specified update interval.  <a href="UDPC_8h.html#a1a50763773d55aa7a2a9c7ad69575833">More...</a><br /></td></tr>
<tr class="separator:a1a50763773d55aa7a2a9c7ad69575833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404d2c7a83903004f928737241ecc63a"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a404d2c7a83903004f928737241ecc63a">UDPC_disable_threaded_update</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:a404d2c7a83903004f928737241ecc63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables auto updating on a separate thread for the given UDPC_HContext.  <a href="UDPC_8h.html#a404d2c7a83903004f928737241ecc63a">More...</a><br /></td></tr>
<tr class="separator:a404d2c7a83903004f928737241ecc63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01480f803b063e2b44794420df0f671"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#ac01480f803b063e2b44794420df0f671">UDPC_is_valid_context</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:ac01480f803b063e2b44794420df0f671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given UDPC_HContext is valid (successfully initialized)  <a href="UDPC_8h.html#ac01480f803b063e2b44794420df0f671">More...</a><br /></td></tr>
<tr class="separator:ac01480f803b063e2b44794420df0f671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0e88866d4c5cb9c0676bc8d7df574e"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#aad0e88866d4c5cb9c0676bc8d7df574e">UDPC_destroy</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:aad0e88866d4c5cb9c0676bc8d7df574e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up the UDPC_HContext.  <a href="UDPC_8h.html#aad0e88866d4c5cb9c0676bc8d7df574e">More...</a><br /></td></tr>
<tr class="separator:aad0e88866d4c5cb9c0676bc8d7df574e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fefba9edca7cd0a81d97ac27c70c0b"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a68fefba9edca7cd0a81d97ac27c70c0b">UDPC_update</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:a68fefba9edca7cd0a81d97ac27c70c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the context.  <a href="UDPC_8h.html#a68fefba9edca7cd0a81d97ac27c70c0b">More...</a><br /></td></tr>
<tr class="separator:a68fefba9edca7cd0a81d97ac27c70c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1192e0307f75feeac888fe5d49976f55"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a1192e0307f75feeac888fe5d49976f55">UDPC_client_initiate_connection</a> (UDPC_HContext ctx, <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> connectionId, int enableLibSodium)</td></tr>
<tr class="memdesc:a1192e0307f75feeac888fe5d49976f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a connection to a server peer.  <a href="UDPC_8h.html#a1192e0307f75feeac888fe5d49976f55">More...</a><br /></td></tr>
<tr class="separator:a1192e0307f75feeac888fe5d49976f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7527954b63f502479bdd3771df7cf3a4"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a7527954b63f502479bdd3771df7cf3a4">UDPC_queue_send</a> (UDPC_HContext ctx, <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> destinationId, int isChecked, const void *data, uint32_t size)</td></tr>
<tr class="memdesc:a7527954b63f502479bdd3771df7cf3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a packet to be sent to the specified peer.  <a href="UDPC_8h.html#a7527954b63f502479bdd3771df7cf3a4">More...</a><br /></td></tr>
<tr class="separator:a7527954b63f502479bdd3771df7cf3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f67ad23ae34b647b7f4dd17a8a96dd"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#aa3f67ad23ae34b647b7f4dd17a8a96dd">UDPC_get_queue_send_current_size</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:aa3f67ad23ae34b647b7f4dd17a8a96dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the data structure holding queued packets.  <a href="UDPC_8h.html#aa3f67ad23ae34b647b7f4dd17a8a96dd">More...</a><br /></td></tr>
<tr class="separator:aa3f67ad23ae34b647b7f4dd17a8a96dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb87c1522d353bd9fde4c94ec8454c2"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a1fb87c1522d353bd9fde4c94ec8454c2">UDPC_get_queued_size</a> (UDPC_HContext ctx, <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> id, int *exists)</td></tr>
<tr class="memdesc:a1fb87c1522d353bd9fde4c94ec8454c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of a connection's queue of queued packets.  <a href="UDPC_8h.html#a1fb87c1522d353bd9fde4c94ec8454c2">More...</a><br /></td></tr>
<tr class="separator:a1fb87c1522d353bd9fde4c94ec8454c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7983f38fe13677f5b35b90cefa54974f"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a7983f38fe13677f5b35b90cefa54974f">UDPC_get_max_queued_size</a> ()</td></tr>
<tr class="memdesc:a7983f38fe13677f5b35b90cefa54974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size limit of a connection's queue of queued packets.  <a href="UDPC_8h.html#a7983f38fe13677f5b35b90cefa54974f">More...</a><br /></td></tr>
<tr class="separator:a7983f38fe13677f5b35b90cefa54974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e217a02b2e8ba05568aabfaecbcdcb"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a32e217a02b2e8ba05568aabfaecbcdcb">UDPC_set_accept_new_connections</a> (UDPC_HContext ctx, int isAccepting)</td></tr>
<tr class="memdesc:a32e217a02b2e8ba05568aabfaecbcdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether or not the UDPC context will accept new connections.  <a href="UDPC_8h.html#a32e217a02b2e8ba05568aabfaecbcdcb">More...</a><br /></td></tr>
<tr class="separator:a32e217a02b2e8ba05568aabfaecbcdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bc5cc29862c93e938ac8a625c56380"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a44bc5cc29862c93e938ac8a625c56380">UDPC_drop_connection</a> (UDPC_HContext ctx, <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> connectionId, int dropAllWithAddr)</td></tr>
<tr class="memdesc:a44bc5cc29862c93e938ac8a625c56380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops an existing connection to a peer.  <a href="UDPC_8h.html#a44bc5cc29862c93e938ac8a625c56380">More...</a><br /></td></tr>
<tr class="separator:a44bc5cc29862c93e938ac8a625c56380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a555a011e95445ed4a2aa88deb17082"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a4a555a011e95445ed4a2aa88deb17082">UDPC_has_connection</a> (UDPC_HContext ctx, <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> connectionId)</td></tr>
<tr class="memdesc:a4a555a011e95445ed4a2aa88deb17082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a connection exists to the peer identified by the given <code>connectionId</code>.  <a href="UDPC_8h.html#a4a555a011e95445ed4a2aa88deb17082">More...</a><br /></td></tr>
<tr class="separator:a4a555a011e95445ed4a2aa88deb17082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4355331c9b2797af0c13ce16515547"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a6b4355331c9b2797af0c13ce16515547">UDPC_get_list_connected</a> (UDPC_HContext ctx, unsigned int *size)</td></tr>
<tr class="memdesc:a6b4355331c9b2797af0c13ce16515547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a dynamically allocated array of connected peers' identifiers.  <a href="UDPC_8h.html#a6b4355331c9b2797af0c13ce16515547">More...</a><br /></td></tr>
<tr class="separator:a6b4355331c9b2797af0c13ce16515547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8880067a93211c257763c42264f6ceef"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a8880067a93211c257763c42264f6ceef">UDPC_free_list_connected</a> (<a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> *list)</td></tr>
<tr class="memdesc:a8880067a93211c257763c42264f6ceef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up a dynamically allocated array of connected peers' identifiers.  <a href="UDPC_8h.html#a8880067a93211c257763c42264f6ceef">More...</a><br /></td></tr>
<tr class="separator:a8880067a93211c257763c42264f6ceef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6fb21c6f5b44123e2660f84561d404"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#aab6fb21c6f5b44123e2660f84561d404">UDPC_get_protocol_id</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:aab6fb21c6f5b44123e2660f84561d404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the protocol id of the UDPC context.  <a href="UDPC_8h.html#aab6fb21c6f5b44123e2660f84561d404">More...</a><br /></td></tr>
<tr class="separator:aab6fb21c6f5b44123e2660f84561d404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0720bec1922660c983b1b3d9f6a5de3a"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a0720bec1922660c983b1b3d9f6a5de3a">UDPC_set_protocol_id</a> (UDPC_HContext ctx, uint32_t id)</td></tr>
<tr class="memdesc:a0720bec1922660c983b1b3d9f6a5de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the protocol id of the UDPC context.  <a href="UDPC_8h.html#a0720bec1922660c983b1b3d9f6a5de3a">More...</a><br /></td></tr>
<tr class="separator:a0720bec1922660c983b1b3d9f6a5de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c7d69eeda20e98696d5c89bbbab096"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT UDPC_LoggingType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#ad0c7d69eeda20e98696d5c89bbbab096">UDPC_get_logging_type</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:ad0c7d69eeda20e98696d5c89bbbab096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the logging type of the UDPC context.  <a href="UDPC_8h.html#ad0c7d69eeda20e98696d5c89bbbab096">More...</a><br /></td></tr>
<tr class="separator:ad0c7d69eeda20e98696d5c89bbbab096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c90dc723e67a07bf65c1fc97e526305"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT UDPC_LoggingType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a6c90dc723e67a07bf65c1fc97e526305">UDPC_set_logging_type</a> (UDPC_HContext ctx, UDPC_LoggingType loggingType)</td></tr>
<tr class="memdesc:a6c90dc723e67a07bf65c1fc97e526305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the logging type of the UDPC context.  <a href="UDPC_8h.html#a6c90dc723e67a07bf65c1fc97e526305">More...</a><br /></td></tr>
<tr class="separator:a6c90dc723e67a07bf65c1fc97e526305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c74f1b9ee0fec610087f83096c9679d"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a8c74f1b9ee0fec610087f83096c9679d">UDPC_get_receiving_events</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:a8c74f1b9ee0fec610087f83096c9679d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the UDPC context will record events.  <a href="UDPC_8h.html#a8c74f1b9ee0fec610087f83096c9679d">More...</a><br /></td></tr>
<tr class="separator:a8c74f1b9ee0fec610087f83096c9679d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380c91ee395cff22189c7988c3381787"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a380c91ee395cff22189c7988c3381787">UDPC_set_receiving_events</a> (UDPC_HContext ctx, int isReceivingEvents)</td></tr>
<tr class="memdesc:a380c91ee395cff22189c7988c3381787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not UDPC will record events.  <a href="UDPC_8h.html#a380c91ee395cff22189c7988c3381787">More...</a><br /></td></tr>
<tr class="separator:a380c91ee395cff22189c7988c3381787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c05c6fe89edde1e05ba9b6d8b5f7510"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT <a class="el" href="structUDPC__Event.html">UDPC_Event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a2c05c6fe89edde1e05ba9b6d8b5f7510">UDPC_get_event</a> (UDPC_HContext ctx, unsigned long *remaining)</td></tr>
<tr class="memdesc:a2c05c6fe89edde1e05ba9b6d8b5f7510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a recorded event.  <a href="UDPC_8h.html#a2c05c6fe89edde1e05ba9b6d8b5f7510">More...</a><br /></td></tr>
<tr class="separator:a2c05c6fe89edde1e05ba9b6d8b5f7510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa8655a4e7e3475be441060e92213b3"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT <a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#affa8655a4e7e3475be441060e92213b3">UDPC_get_received</a> (UDPC_HContext ctx, unsigned long *remaining)</td></tr>
<tr class="memdesc:affa8655a4e7e3475be441060e92213b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a received packet from a given UDPC context.  <a href="UDPC_8h.html#affa8655a4e7e3475be441060e92213b3">More...</a><br /></td></tr>
<tr class="separator:affa8655a4e7e3475be441060e92213b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ed6dcb37c6024486fad28ab0bed845"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a68ed6dcb37c6024486fad28ab0bed845">UDPC_free_PacketInfo</a> (<a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a> pInfo)</td></tr>
<tr class="memdesc:a68ed6dcb37c6024486fad28ab0bed845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structUDPC__PacketInfo.html" title="Data representing a received/sent packet.">UDPC_PacketInfo</a>.  <a href="UDPC_8h.html#a68ed6dcb37c6024486fad28ab0bed845">More...</a><br /></td></tr>
<tr class="separator:a68ed6dcb37c6024486fad28ab0bed845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77c746ea0401664e11bfd76c56e94f5"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#ad77c746ea0401664e11bfd76c56e94f5">UDPC_free_PacketInfo_ptr</a> (<a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a> *pInfoPtr)</td></tr>
<tr class="memdesc:ad77c746ea0401664e11bfd76c56e94f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a <a class="el" href="structUDPC__PacketInfo.html" title="Data representing a received/sent packet.">UDPC_PacketInfo</a>.  <a href="UDPC_8h.html#ad77c746ea0401664e11bfd76c56e94f5">More...</a><br /></td></tr>
<tr class="separator:ad77c746ea0401664e11bfd76c56e94f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a7d5c0a17cf3351dbe5abf5f70df1"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#abd0a7d5c0a17cf3351dbe5abf5f70df1">UDPC_set_libsodium_keys</a> (UDPC_HContext ctx, const unsigned char *sk, const unsigned char *pk)</td></tr>
<tr class="memdesc:abd0a7d5c0a17cf3351dbe5abf5f70df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets public/private keys used for packet verification.  <a href="UDPC_8h.html#abd0a7d5c0a17cf3351dbe5abf5f70df1">More...</a><br /></td></tr>
<tr class="separator:abd0a7d5c0a17cf3351dbe5abf5f70df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7eb0c77561f84a63dad29388d099fbe"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#ad7eb0c77561f84a63dad29388d099fbe">UDPC_set_libsodium_key_easy</a> (UDPC_HContext ctx, const unsigned char *sk)</td></tr>
<tr class="memdesc:ad7eb0c77561f84a63dad29388d099fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the public/private keys used for packet verification.  <a href="UDPC_8h.html#ad7eb0c77561f84a63dad29388d099fbe">More...</a><br /></td></tr>
<tr class="separator:ad7eb0c77561f84a63dad29388d099fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a5131b90653ccbfc86ad5db4031ba9"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a62a5131b90653ccbfc86ad5db4031ba9">UDPC_unset_libsodium_keys</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:a62a5131b90653ccbfc86ad5db4031ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes set keys if any used for packet verification.  <a href="UDPC_8h.html#a62a5131b90653ccbfc86ad5db4031ba9">More...</a><br /></td></tr>
<tr class="separator:a62a5131b90653ccbfc86ad5db4031ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f9bf85a02ddd1b4c921fe9b6694fe8"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a71f9bf85a02ddd1b4c921fe9b6694fe8">UDPC_add_whitelist_pk</a> (UDPC_HContext ctx, const unsigned char *pk)</td></tr>
<tr class="memdesc:a71f9bf85a02ddd1b4c921fe9b6694fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a public key to the whitelist.  <a href="UDPC_8h.html#a71f9bf85a02ddd1b4c921fe9b6694fe8">More...</a><br /></td></tr>
<tr class="separator:a71f9bf85a02ddd1b4c921fe9b6694fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94660d04e7f9b4d9c51a7b2c67707172"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a94660d04e7f9b4d9c51a7b2c67707172">UDPC_has_whitelist_pk</a> (UDPC_HContext ctx, const unsigned char *pk)</td></tr>
<tr class="memdesc:a94660d04e7f9b4d9c51a7b2c67707172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a public key is in the whitelist.  <a href="UDPC_8h.html#a94660d04e7f9b4d9c51a7b2c67707172">More...</a><br /></td></tr>
<tr class="separator:a94660d04e7f9b4d9c51a7b2c67707172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2d3284e5c45d6cd888154e813a1383"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#abc2d3284e5c45d6cd888154e813a1383">UDPC_remove_whitelist_pk</a> (UDPC_HContext ctx, const unsigned char *pk)</td></tr>
<tr class="memdesc:abc2d3284e5c45d6cd888154e813a1383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a public key from the whitelist.  <a href="UDPC_8h.html#abc2d3284e5c45d6cd888154e813a1383">More...</a><br /></td></tr>
<tr class="separator:abc2d3284e5c45d6cd888154e813a1383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2e0c6a6a442db2cb3223d26f849d26"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a0e2e0c6a6a442db2cb3223d26f849d26">UDPC_clear_whitelist</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:a0e2e0c6a6a442db2cb3223d26f849d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the public key whitelist.  <a href="UDPC_8h.html#a0e2e0c6a6a442db2cb3223d26f849d26">More...</a><br /></td></tr>
<tr class="separator:a0e2e0c6a6a442db2cb3223d26f849d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79769e36a92c346c6c410be158ddfe4"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#ab79769e36a92c346c6c410be158ddfe4">UDPC_get_auth_policy</a> (UDPC_HContext ctx)</td></tr>
<tr class="memdesc:ab79769e36a92c346c6c410be158ddfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets how peers are handled regarding public key verification.  <a href="UDPC_8h.html#ab79769e36a92c346c6c410be158ddfe4">More...</a><br /></td></tr>
<tr class="separator:ab79769e36a92c346c6c410be158ddfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0dbbd258e17844a2f9a0e277789581"><td class="memItemLeft" align="right" valign="top">UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="UDPC_8h.html#a8d0dbbd258e17844a2f9a0e277789581">UDPC_set_auth_policy</a> (UDPC_HContext ctx, int value)</td></tr>
<tr class="memdesc:a8d0dbbd258e17844a2f9a0e277789581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets how peers are handled regarding public key verification.  <a href="UDPC_8h.html#a8d0dbbd258e17844a2f9a0e277789581">More...</a><br /></td></tr>
<tr class="separator:a8d0dbbd258e17844a2f9a0e277789581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3c613a0d96a075ccddfba1e8900828"><td class="memItemLeft" align="right" valign="top"><a id="a5a3c613a0d96a075ccddfba1e8900828" name="a5a3c613a0d96a075ccddfba1e8900828"></a>
UDPC_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_atostr_cid</b> (UDPC_HContext ctx, <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> connectionId)</td></tr>
<tr class="separator:a5a3c613a0d96a075ccddfba1e8900828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2401b133c0aae43c5d69304dabbdcc"><td class="memItemLeft" align="right" valign="top"><a id="a9e2401b133c0aae43c5d69304dabbdcc" name="a9e2401b133c0aae43c5d69304dabbdcc"></a>
UDPC_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_atostr</b> (UDPC_HContext ctx, UDPC_IPV6_ADDR_TYPE addr)</td></tr>
<tr class="separator:a9e2401b133c0aae43c5d69304dabbdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae8e7d87f785dd3b3353a00005c3dc6"><td class="memItemLeft" align="right" valign="top"><a id="a2ae8e7d87f785dd3b3353a00005c3dc6" name="a2ae8e7d87f785dd3b3353a00005c3dc6"></a>
UDPC_EXPORT UDPC_IPV6_ADDR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_strtoa</b> (const char *addrStr)</td></tr>
<tr class="memdesc:a2ae8e7d87f785dd3b3353a00005c3dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">addrStr must be a valid ipv6 address or a valid ipv4 address <br /></td></tr>
<tr class="separator:a2ae8e7d87f785dd3b3353a00005c3dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c4ad0e4ce9a97b3506335aae16cb49"><td class="memItemLeft" align="right" valign="top"><a id="ad1c4ad0e4ce9a97b3506335aae16cb49" name="ad1c4ad0e4ce9a97b3506335aae16cb49"></a>
UDPC_EXPORT UDPC_IPV6_ADDR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_strtoa_link</b> (const char *addrStr, uint32_t *linkId_out)</td></tr>
<tr class="separator:ad1c4ad0e4ce9a97b3506335aae16cb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac891801289f8be17e5db81b5de781190"><td class="memItemLeft" align="right" valign="top"><a id="ac891801289f8be17e5db81b5de781190" name="ac891801289f8be17e5db81b5de781190"></a>
UDPC_EXPORT UDPC_IPV6_ADDR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_a4toa6</b> (uint32_t a4_be)</td></tr>
<tr class="separator:ac891801289f8be17e5db81b5de781190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f81a1abecf149abe26902ca5d72e316"><td class="memItemLeft" align="right" valign="top"><a id="a5f81a1abecf149abe26902ca5d72e316" name="a5f81a1abecf149abe26902ca5d72e316"></a>
UDPC_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_is_big_endian</b> ()</td></tr>
<tr class="separator:a5f81a1abecf149abe26902ca5d72e316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09093c7edd8ed04407c84a94e0d02587"><td class="memItemLeft" align="right" valign="top"><a id="a09093c7edd8ed04407c84a94e0d02587" name="a09093c7edd8ed04407c84a94e0d02587"></a>
UDPC_EXPORT uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_no16i</b> (uint16_t i)</td></tr>
<tr class="separator:a09093c7edd8ed04407c84a94e0d02587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e62beb3d497732f5e1d79e19878198c"><td class="memItemLeft" align="right" valign="top"><a id="a3e62beb3d497732f5e1d79e19878198c" name="a3e62beb3d497732f5e1d79e19878198c"></a>
UDPC_EXPORT uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_no32i</b> (uint32_t i)</td></tr>
<tr class="separator:a3e62beb3d497732f5e1d79e19878198c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6d9407ed6743a23283d8711652d757"><td class="memItemLeft" align="right" valign="top"><a id="a0d6d9407ed6743a23283d8711652d757" name="a0d6d9407ed6743a23283d8711652d757"></a>
UDPC_EXPORT uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_no64i</b> (uint64_t i)</td></tr>
<tr class="separator:a0d6d9407ed6743a23283d8711652d757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f1ec575cd8a1020bf4d53a72497ab6"><td class="memItemLeft" align="right" valign="top"><a id="a61f1ec575cd8a1020bf4d53a72497ab6" name="a61f1ec575cd8a1020bf4d53a72497ab6"></a>
UDPC_EXPORT float&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_no32f</b> (float f)</td></tr>
<tr class="separator:a61f1ec575cd8a1020bf4d53a72497ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a1a33c4d5dcd4f3e829ce4b15df11c"><td class="memItemLeft" align="right" valign="top"><a id="a93a1a33c4d5dcd4f3e829ce4b15df11c" name="a93a1a33c4d5dcd4f3e829ce4b15df11c"></a>
UDPC_EXPORT double&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_no64f</b> (double f)</td></tr>
<tr class="separator:a93a1a33c4d5dcd4f3e829ce4b15df11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa5c197773a0914125cb358771139065c"><td class="memItemLeft" align="right" valign="top"><a id="aa5c197773a0914125cb358771139065c" name="aa5c197773a0914125cb358771139065c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_SILENT</b></td></tr>
<tr class="memdesc:aa5c197773a0914125cb358771139065c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does not log anything. <br /></td></tr>
<tr class="separator:aa5c197773a0914125cb358771139065c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04213a4287500a9c5330f543eac3103"><td class="memItemLeft" align="right" valign="top"><a id="ac04213a4287500a9c5330f543eac3103" name="ac04213a4287500a9c5330f543eac3103"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_ERROR</b></td></tr>
<tr class="memdesc:ac04213a4287500a9c5330f543eac3103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only log errors. <br /></td></tr>
<tr class="separator:ac04213a4287500a9c5330f543eac3103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc5d705069747eb439a1c5607baac17"><td class="memItemLeft" align="right" valign="top"><a id="a9cc5d705069747eb439a1c5607baac17" name="a9cc5d705069747eb439a1c5607baac17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_WARNING</b></td></tr>
<tr class="memdesc:a9cc5d705069747eb439a1c5607baac17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log errors and warnings. <br /></td></tr>
<tr class="separator:a9cc5d705069747eb439a1c5607baac17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248f51c4df127b7fd3a5c91ad5509d15"><td class="memItemLeft" align="right" valign="top"><a id="a248f51c4df127b7fd3a5c91ad5509d15" name="a248f51c4df127b7fd3a5c91ad5509d15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_INFO</b></td></tr>
<tr class="memdesc:a248f51c4df127b7fd3a5c91ad5509d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log errors, warnings, and info. <br /></td></tr>
<tr class="separator:a248f51c4df127b7fd3a5c91ad5509d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5741af4e5cf1da40fe4a7b92cd1c431"><td class="memItemLeft" align="right" valign="top"><a id="ad5741af4e5cf1da40fe4a7b92cd1c431" name="ad5741af4e5cf1da40fe4a7b92cd1c431"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_VERBOSE</b></td></tr>
<tr class="memdesc:ad5741af4e5cf1da40fe4a7b92cd1c431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log errors, warning, info, and verbose. <br /></td></tr>
<tr class="separator:ad5741af4e5cf1da40fe4a7b92cd1c431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ecd597f88d458ed108f33e4f0a6612"><td class="memItemLeft" align="right" valign="top"><a id="a96ecd597f88d458ed108f33e4f0a6612" name="a96ecd597f88d458ed108f33e4f0a6612"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_AUTH_POLICY_FALLBACK</b> =0</td></tr>
<tr class="memdesc:a96ecd597f88d458ed108f33e4f0a6612"><td class="mdescLeft">&#160;</td><td class="mdescRight">All peers will not be denied regardless of use of public key verification. <br /></td></tr>
<tr class="separator:a96ecd597f88d458ed108f33e4f0a6612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af4629253b3ed1f411015410cee9ad3"><td class="memItemLeft" align="right" valign="top"><a id="a6af4629253b3ed1f411015410cee9ad3" name="a6af4629253b3ed1f411015410cee9ad3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_AUTH_POLICY_STRICT</b></td></tr>
<tr class="memdesc:a6af4629253b3ed1f411015410cee9ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only peers with public key verification will be allowed. <br /></td></tr>
<tr class="separator:a6af4629253b3ed1f411015410cee9ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72343e4853bf37ad09cb5cebfadc0de6"><td class="memItemLeft" align="right" valign="top"><a id="a72343e4853bf37ad09cb5cebfadc0de6" name="a72343e4853bf37ad09cb5cebfadc0de6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_ET_NONE</b></td></tr>
<tr class="separator:a72343e4853bf37ad09cb5cebfadc0de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a88eb4529c120f49036db4b33505cd"><td class="memItemLeft" align="right" valign="top"><a id="a21a88eb4529c120f49036db4b33505cd" name="a21a88eb4529c120f49036db4b33505cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_ET_REQUEST_CONNECT</b></td></tr>
<tr class="separator:a21a88eb4529c120f49036db4b33505cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4bd6a74bd9c6d2d93ca1c1e12bcf94"><td class="memItemLeft" align="right" valign="top"><a id="a6b4bd6a74bd9c6d2d93ca1c1e12bcf94" name="a6b4bd6a74bd9c6d2d93ca1c1e12bcf94"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_ET_REQUEST_DISCONNECT</b></td></tr>
<tr class="separator:a6b4bd6a74bd9c6d2d93ca1c1e12bcf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb673b618b1a667fde68d33b1458aba"><td class="memItemLeft" align="right" valign="top"><a id="abcb673b618b1a667fde68d33b1458aba" name="abcb673b618b1a667fde68d33b1458aba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_ET_CONNECTED</b></td></tr>
<tr class="separator:abcb673b618b1a667fde68d33b1458aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac839f06a0f38fbe1234f834c21595ef"><td class="memItemLeft" align="right" valign="top"><a id="aac839f06a0f38fbe1234f834c21595ef" name="aac839f06a0f38fbe1234f834c21595ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_ET_DISCONNECTED</b></td></tr>
<tr class="separator:aac839f06a0f38fbe1234f834c21595ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8619c6ec9a86458dfa4492967586a5d5"><td class="memItemLeft" align="right" valign="top"><a id="a8619c6ec9a86458dfa4492967586a5d5" name="a8619c6ec9a86458dfa4492967586a5d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_ET_FAIL_CONNECT</b></td></tr>
<tr class="separator:a8619c6ec9a86458dfa4492967586a5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339bec321cb608fcd90fcd7cea102b11"><td class="memItemLeft" align="right" valign="top"><a id="a339bec321cb608fcd90fcd7cea102b11" name="a339bec321cb608fcd90fcd7cea102b11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UDPC_ET_GOOD_MODE</b></td></tr>
<tr class="separator:a339bec321cb608fcd90fcd7cea102b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Public API for UDPConnection. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a228cd7ddf56a4e76e216bc3b80e8bd4a" name="a228cd7ddf56a4e76e216bc3b80e8bd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228cd7ddf56a4e76e216bc3b80e8bd4a">&#9670;&#160;</a></span>UDPC_AuthPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum UDPC_EXPORT <a class="el" href="UDPC_8h.html#a228cd7ddf56a4e76e216bc3b80e8bd4a">UDPC_AuthPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Note auth policy will only take effect if public key verification of packets is enabled (if libsodium is enabled). </p>

</div>
</div>
<a id="ae5afb11964c7a55edf34ddf9097779b2" name="ae5afb11964c7a55edf34ddf9097779b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5afb11964c7a55edf34ddf9097779b2">&#9670;&#160;</a></span>UDPC_ConnectionId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data identifying a peer via addr, port, and scope_id. </p>
<p >This struct needn't be used directly; use <a class="el" href="UDPC_8h.html#aea7e32ca9fdc04530f95c97459391e6d" title="Creates an UDPC_ConnectionId with the given addr and port.">UDPC_create_id()</a>, <a class="el" href="UDPC_8h.html#ab7cb345ce117c04017afd443e5748f19" title="Creates an UDPC_ConnectionId with the given addr, scope_id, and port.">UDPC_create_id_full()</a>, <a class="el" href="UDPC_8h.html#a0fa3e1e54877029a226ab9cfb74215df" title="Creates an UDPC_ConnectionId with the given port.">UDPC_create_id_anyaddr()</a>, or <a class="el" href="UDPC_8h.html#a8b80d2df882f03aeee8a92bed7fb0131" title="Creates an UDPC_ConnectionId with the given addr string and port.">UDPC_create_id_easy()</a> to create one. This struct does not hold dynamic data, so there is no need to free it. </p>

</div>
</div>
<a id="a7b3215b65686670720f098eda2ca1eed" name="a7b3215b65686670720f098eda2ca1eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3215b65686670720f098eda2ca1eed">&#9670;&#160;</a></span>UDPC_Event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct UDPC_EXPORT <a class="el" href="structUDPC__Event.html">UDPC_Event</a> <a class="el" href="structUDPC__Event.html">UDPC_Event</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A struct containing information related to the type of event. </p>
<p >Note that instances of this struct received from a call to <a class="el" href="UDPC_8h.html#a2c05c6fe89edde1e05ba9b6d8b5f7510" title="Gets a recorded event.">UDPC_get_event()</a> will not store any useful data in its union member variable <code>v</code> (it will only be used internally). Thus, all events received through a call to <a class="el" href="UDPC_8h.html#a2c05c6fe89edde1e05ba9b6d8b5f7510" title="Gets a recorded event.">UDPC_get_event()</a> will contain a valid <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> <code>conId</code> that identifies the peer that the event is referring to. </p>

</div>
</div>
<a id="adaa0534bf7f04bb2f6ce8975c99c4af0" name="adaa0534bf7f04bb2f6ce8975c99c4af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa0534bf7f04bb2f6ce8975c99c4af0">&#9670;&#160;</a></span>UDPC_EventType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum UDPC_EXPORT <a class="el" href="UDPC_8h.html#adaa0534bf7f04bb2f6ce8975c99c4af0">UDPC_EventType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enum describing the type of event. </p>
<p >Note that only the following values will be presented when using <a class="el" href="UDPC_8h.html#a2c05c6fe89edde1e05ba9b6d8b5f7510" title="Gets a recorded event.">UDPC_get_event()</a></p><ul>
<li>UDPC_ET_NONE: No events have ocurred</li>
<li>UDPC_ET_CONNECTED: A peer has initiated a connection</li>
<li>UDPC_ET_DISCONNECTED: A peer has disconnected</li>
<li>UDPC_ET_FAIL_CONNECT: Failed to establish a connection to server peer</li>
<li>UDPC_ET_GOOD_MODE: The connection has switched to "good mode"</li>
<li>UDPC_ET_BAD_MODE: The connection has switched to "bad mode"</li>
</ul>
<p >The other unmentioned enum values are used internally, and should never be returned in a call to <a class="el" href="UDPC_8h.html#a2c05c6fe89edde1e05ba9b6d8b5f7510" title="Gets a recorded event.">UDPC_get_event()</a>.</p>
<p >All events returned by <a class="el" href="UDPC_8h.html#a2c05c6fe89edde1e05ba9b6d8b5f7510" title="Gets a recorded event.">UDPC_get_event()</a> will have set the member variable <code>conId</code> in the <a class="el" href="structUDPC__Event.html" title="A struct containing information related to the type of event.">UDPC_Event</a> which refers to the peer with which the event ocurred. </p>

</div>
</div>
<a id="ae0261958047ebb5c6a402aa805e4e55b" name="ae0261958047ebb5c6a402aa805e4e55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0261958047ebb5c6a402aa805e4e55b">&#9670;&#160;</a></span>UDPC_PacketInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct UDPC_EXPORT <a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a> <a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data representing a received/sent packet. </p>
<p >If data is NULL or dataSize is 0, then this packet is invalid.</p>
<dl class="section warning"><dt>Warning</dt><dd>This struct must be free'd with a call to <a class="el" href="UDPC_8h.html#ad77c746ea0401664e11bfd76c56e94f5">UDPC_free_PacketInfo_ptr</a> or <a class="el" href="UDPC_8h.html#a68ed6dcb37c6024486fad28ab0bed845">UDPC_free_PacketInfo</a> to avoid a memory leak. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a71f9bf85a02ddd1b4c921fe9b6694fe8" name="a71f9bf85a02ddd1b4c921fe9b6694fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f9bf85a02ddd1b4c921fe9b6694fe8">&#9670;&#160;</a></span>UDPC_add_whitelist_pk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_add_whitelist_pk </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a public key to the whitelist. </p>
<p >By default the whitelist is empty and any peer regardless of key will not be denied connection.</p>
<p >This function adds one public key to the whitelist. If the whitelist is not empty, then all peers that do not have the matching public key will be denied connection.</p>
<p >Note that public key verification will not occur if it is not enabled during the call to <a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2" title="Creates an UDPC_HContext that holds state for connections.">UDPC_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the whitelist on success, zero otherwise </dd></dl>

</div>
</div>
<a id="a0e2e0c6a6a442db2cb3223d26f849d26" name="a0e2e0c6a6a442db2cb3223d26f849d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2e0c6a6a442db2cb3223d26f849d26">&#9670;&#160;</a></span>UDPC_clear_whitelist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_clear_whitelist </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the public key whitelist. </p>
<p >If the whitelist is empty, then no connections will be denied.</p>
<p >If there are keys in the whitelist, then new connections will only be allowed if the peer uses a public key in the whitelist.</p>
<p >Note that public key verification will not occur if it is not enabled during the call to <a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2" title="Creates an UDPC_HContext that holds state for connections.">UDPC_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Zero if the context is invalid or libsodium is not enabled, non-zero if the whitelist was successfully cleared </dd></dl>

</div>
</div>
<a id="a1192e0307f75feeac888fe5d49976f55" name="a1192e0307f75feeac888fe5d49976f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1192e0307f75feeac888fe5d49976f55">&#9670;&#160;</a></span>UDPC_client_initiate_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT void UDPC_client_initiate_connection </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td>
          <td class="paramname"><em>connectionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enableLibSodium</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate a connection to a server peer. </p>
<p >Note that this function does nothing on a server context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context to initiate a connection from </td></tr>
    <tr><td class="paramname">connectionId</td><td>The server peer to initiate a connection to </td></tr>
    <tr><td class="paramname">enableLibSodium</td><td>If packet headers should be verified with the server peer (Fails if UDPC was not compiled with libsodium support) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea7e32ca9fdc04530f95c97459391e6d" name="aea7e32ca9fdc04530f95c97459391e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7e32ca9fdc04530f95c97459391e6d">&#9670;&#160;</a></span>UDPC_create_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> UDPC_create_id </td>
          <td>(</td>
          <td class="paramtype">UDPC_IPV6_ADDR_TYPE&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> with the given addr and port. </p>
<p >port should be in native byte order (not network/big-endian). This means that there is no need to convert the 16-bit value to network byte order, this will be done automatically by this library when necessary (without modifying the value in the used <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> </dd></dl>

</div>
</div>
<a id="a0fa3e1e54877029a226ab9cfb74215df" name="a0fa3e1e54877029a226ab9cfb74215df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa3e1e54877029a226ab9cfb74215df">&#9670;&#160;</a></span>UDPC_create_id_anyaddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> UDPC_create_id_anyaddr </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> with the given port. </p>
<p >The address contained in the returned <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> will be zeroed out (the "anyaddr" address). port should be in native byte order (not network/big-endian).</p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> </dd></dl>

</div>
</div>
<a id="a8b80d2df882f03aeee8a92bed7fb0131" name="a8b80d2df882f03aeee8a92bed7fb0131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b80d2df882f03aeee8a92bed7fb0131">&#9670;&#160;</a></span>UDPC_create_id_easy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> UDPC_create_id_easy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addrString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> with the given addr string and port. </p>
<p >The address string should be a valid ipv6 or ipv4 address. (If an ipv4 address is given, the internal address of the returned <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> will be ipv4-mapped ipv6 address.) port should be in native byte order (not network/big-endian).</p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> </dd></dl>

</div>
</div>
<a id="ab7cb345ce117c04017afd443e5748f19" name="ab7cb345ce117c04017afd443e5748f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cb345ce117c04017afd443e5748f19">&#9670;&#160;</a></span>UDPC_create_id_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> UDPC_create_id_full </td>
          <td>(</td>
          <td class="paramtype">UDPC_IPV6_ADDR_TYPE&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>scope_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> with the given addr, scope_id, and port. </p>
<p >port should be in native byte order (not network/big-endian).</p>
<dl class="section return"><dt>Returns</dt><dd>An initialized <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a> </dd></dl>

</div>
</div>
<a id="aad0e88866d4c5cb9c0676bc8d7df574e" name="aad0e88866d4c5cb9c0676bc8d7df574e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0e88866d4c5cb9c0676bc8d7df574e">&#9670;&#160;</a></span>UDPC_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT void UDPC_destroy </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up the UDPC_HContext. </p>
<p >If auto updating was enabled for the given context, it will gracefully stop the thread before cleaning up the context.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called after a UDPC_HContext is no longer used to avoid memory leaks. </dd></dl>

</div>
</div>
<a id="a404d2c7a83903004f928737241ecc63a" name="a404d2c7a83903004f928737241ecc63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404d2c7a83903004f928737241ecc63a">&#9670;&#160;</a></span>UDPC_disable_threaded_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_disable_threaded_update </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables auto updating on a separate thread for the given UDPC_HContext. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context to disable auto updating for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if auto updating is disabled. If the context already had auto updating disabled, this function will return zero. </dd></dl>

</div>
</div>
<a id="a44bc5cc29862c93e938ac8a625c56380" name="a44bc5cc29862c93e938ac8a625c56380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bc5cc29862c93e938ac8a625c56380">&#9670;&#160;</a></span>UDPC_drop_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT void UDPC_drop_connection </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td>
          <td class="paramname"><em>connectionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dropAllWithAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drops an existing connection to a peer. </p>
<p >Note that UDPC will send a disconnect packet to the peer before removing the internal connection data handling the connection to that peer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
    <tr><td class="paramname">connectionId</td><td>The identifier of the peer to disconnect from </td></tr>
    <tr><td class="paramname">dropAllWithAddr</td><td>Set to non-zero to drop all peers with the ip address specified in <code>connectionId</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fafce547e9185c29f42d06213b0ff4f" name="a0fafce547e9185c29f42d06213b0ff4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fafce547e9185c29f42d06213b0ff4f">&#9670;&#160;</a></span>UDPC_enable_threaded_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_enable_threaded_update </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables auto updating on a separate thread for the given UDPC_HContext. </p>
<p >By default, the update interval is set to 8 milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context to enable auto updating for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if auto updating is enabled. If the context already had auto updating enabled, this function will return zero. </dd></dl>

</div>
</div>
<a id="a1a50763773d55aa7a2a9c7ad69575833" name="a1a50763773d55aa7a2a9c7ad69575833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a50763773d55aa7a2a9c7ad69575833">&#9670;&#160;</a></span>UDPC_enable_threaded_update_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_enable_threaded_update_ms </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>updateMS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables auto updating on a separate thread for the given UDPC_HContext with the specified update interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context to enable auto updating for </td></tr>
    <tr><td class="paramname">updateMS</td><td>The interval to update at in milliseconds (clamped at a minimum of 4 ms and a maximum of 333 ms) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if auto updating is enabled. If the context already had auto updating enabled, this function will return zero. </dd></dl>

</div>
</div>
<a id="a8880067a93211c257763c42264f6ceef" name="a8880067a93211c257763c42264f6ceef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8880067a93211c257763c42264f6ceef">&#9670;&#160;</a></span>UDPC_free_list_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT void UDPC_free_list_connected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up a dynamically allocated array of connected peers' identifiers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The array to clean up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68ed6dcb37c6024486fad28ab0bed845" name="a68ed6dcb37c6024486fad28ab0bed845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ed6dcb37c6024486fad28ab0bed845">&#9670;&#160;</a></span>UDPC_free_PacketInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT void UDPC_free_PacketInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a>&#160;</td>
          <td class="paramname"><em>pInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="structUDPC__PacketInfo.html" title="Data representing a received/sent packet.">UDPC_PacketInfo</a>. </p>
<p >Internally, the member variable UDPC_PacketInfo::data will be free'd. <a class="el" href="UDPC_8h.html#ad77c746ea0401664e11bfd76c56e94f5">UDPC_free_PacketInfo_ptr</a> is safer to use than this function, as it also zeros out the relevant data to avoid double frees. </p>

</div>
</div>
<a id="ad77c746ea0401664e11bfd76c56e94f5" name="ad77c746ea0401664e11bfd76c56e94f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77c746ea0401664e11bfd76c56e94f5">&#9670;&#160;</a></span>UDPC_free_PacketInfo_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT void UDPC_free_PacketInfo_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a> *&#160;</td>
          <td class="paramname"><em>pInfoPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a <a class="el" href="structUDPC__PacketInfo.html" title="Data representing a received/sent packet.">UDPC_PacketInfo</a>. </p>
<p >This is a safer alternative to <a class="el" href="UDPC_8h.html#a68ed6dcb37c6024486fad28ab0bed845">UDPC_free_PacketInfo</a> because it internally zeroes out the internal pointer and size variables, making it safe to pass the same ptr multiple times to this function as it avoids a double free.</p>
<p >Usage: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a> pinfo = <a class="code hl_function" href="UDPC_8h.html#affa8655a4e7e3475be441060e92213b3">UDPC_get_received</a>(ctx, NULL);</div>
<div class="line"><a class="code hl_function" href="UDPC_8h.html#ad77c746ea0401664e11bfd76c56e94f5">UDPC_free_PacketInfo_ptr</a>(&amp;pinfo);</div>
<div class="line"><a class="code hl_function" href="UDPC_8h.html#ad77c746ea0401664e11bfd76c56e94f5">UDPC_free_PacketInfo_ptr</a>(&amp;pinfo); <span class="comment">// This is safe, no double free.</span></div>
<div class="ttc" id="aUDPC_8h_html_ad77c746ea0401664e11bfd76c56e94f5"><div class="ttname"><a href="UDPC_8h.html#ad77c746ea0401664e11bfd76c56e94f5">UDPC_free_PacketInfo_ptr</a></div><div class="ttdeci">UDPC_EXPORT void UDPC_free_PacketInfo_ptr(UDPC_PacketInfo *pInfoPtr)</div><div class="ttdoc">Frees a UDPC_PacketInfo.</div></div>
<div class="ttc" id="aUDPC_8h_html_affa8655a4e7e3475be441060e92213b3"><div class="ttname"><a href="UDPC_8h.html#affa8655a4e7e3475be441060e92213b3">UDPC_get_received</a></div><div class="ttdeci">UDPC_EXPORT UDPC_PacketInfo UDPC_get_received(UDPC_HContext ctx, unsigned long *remaining)</div><div class="ttdoc">Get a received packet from a given UDPC context.</div></div>
<div class="ttc" id="astructUDPC__PacketInfo_html"><div class="ttname"><a href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a></div><div class="ttdoc">Data representing a received/sent packet.</div><div class="ttdef"><b>Definition:</b> UDPC.h:168</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab79769e36a92c346c6c410be158ddfe4" name="ab79769e36a92c346c6c410be158ddfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79769e36a92c346c6c410be158ddfe4">&#9670;&#160;</a></span>UDPC_get_auth_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_get_auth_policy </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets how peers are handled regarding public key verification. </p>
<p >If libsodium is enabled and the auth policy is "strict", then peers attempting to connect will be denied if they do not have public key verification enabled. Otherwise if the auth policy is "fallback", then peers will not be denied a connection regardless of whether or not they use public key verification of packets.</p>
<p >Note that public key verification will not occur if it is not enabled during the call to <a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2" title="Creates an UDPC_HContext that holds state for connections.">UDPC_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The current auth policy (see <a class="el" href="UDPC_8h.html#a228cd7ddf56a4e76e216bc3b80e8bd4a">UDPC_AuthPolicy</a>) , or zero on fail </dd></dl>

</div>
</div>
<a id="a2c05c6fe89edde1e05ba9b6d8b5f7510" name="a2c05c6fe89edde1e05ba9b6d8b5f7510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c05c6fe89edde1e05ba9b6d8b5f7510">&#9670;&#160;</a></span>UDPC_get_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT <a class="el" href="structUDPC__Event.html">UDPC_Event</a> UDPC_get_event </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a recorded event. </p>
<p >See <a class="el" href="UDPC_8h.html#adaa0534bf7f04bb2f6ce8975c99c4af0">UDPC_EventType</a> for possible types of a <a class="el" href="structUDPC__Event.html" title="A struct containing information related to the type of event.">UDPC_Event</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
    <tr><td class="paramname">remaining</td><td>Pointer to set the number of remaining events that can be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structUDPC__Event.html" title="A struct containing information related to the type of event.">UDPC_Event</a> (will be of type UDPC_ET_NONE if there are no more events) </dd></dl>

</div>
</div>
<a id="a6b4355331c9b2797af0c13ce16515547" name="a6b4355331c9b2797af0c13ce16515547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4355331c9b2797af0c13ce16515547">&#9670;&#160;</a></span>UDPC_get_list_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT <a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a> * UDPC_get_list_connected </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a dynamically allocated array of connected peers' identifiers. </p>
<p >Note that an additional element is appended to the array that is initialized with all fields to zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>One must call <a class="el" href="UDPC_8h.html#a8880067a93211c257763c42264f6ceef" title="Cleans up a dynamically allocated array of connected peers&#39; identifiers.">UDPC_free_list_connected()</a> with the returned array to clean up data to avoid a memory leak</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
    <tr><td class="paramname">size</td><td>Pointer to an unsigned int to set the size of the returned array (set to NULL to not get a size) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated array of identifiers </dd></dl>

</div>
</div>
<a id="ad0c7d69eeda20e98696d5c89bbbab096" name="ad0c7d69eeda20e98696d5c89bbbab096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c7d69eeda20e98696d5c89bbbab096">&#9670;&#160;</a></span>UDPC_get_logging_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT UDPC_LoggingType UDPC_get_logging_type </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the logging type of the UDPC context. </p>
<p >See UDPC_LoggingType for possible values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The logging type of the UDPC context </dd></dl>

</div>
</div>
<a id="a7983f38fe13677f5b35b90cefa54974f" name="a7983f38fe13677f5b35b90cefa54974f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7983f38fe13677f5b35b90cefa54974f">&#9670;&#160;</a></span>UDPC_get_max_queued_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT unsigned long UDPC_get_max_queued_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size limit of a connection's queue of queued packets. </p>
<p >Note that a call to this function does not use any locks, as the limit is known at compile time and is the same for all UDPC connections.</p>
<dl class="section return"><dt>Returns</dt><dd>The size limit of a connection's queue </dd></dl>

</div>
</div>
<a id="aab6fb21c6f5b44123e2660f84561d404" name="aab6fb21c6f5b44123e2660f84561d404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6fb21c6f5b44123e2660f84561d404">&#9670;&#160;</a></span>UDPC_get_protocol_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT uint32_t UDPC_get_protocol_id </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the protocol id of the UDPC context. </p>
<p >UDPC uses the protocol id by prefixing every sent packet with it. Other UDPC instances will only accept packets with the same protocol id.</p>
<p >One can use <a class="el" href="UDPC_8h.html#a0720bec1922660c983b1b3d9f6a5de3a" title="Sets the protocol id of the UDPC context.">UDPC_set_protocol_id()</a> to change it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The protocol id of the given UDPC context </dd></dl>

</div>
</div>
<a id="aa3f67ad23ae34b647b7f4dd17a8a96dd" name="aa3f67ad23ae34b647b7f4dd17a8a96dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f67ad23ae34b647b7f4dd17a8a96dd">&#9670;&#160;</a></span>UDPC_get_queue_send_current_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT unsigned long UDPC_get_queue_send_current_size </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the data structure holding queued packets. </p>
<p >Note that a UDPC context holds a different data structure per established connection that holds a limited amount of packets to send. If a connection's queue is full, it will not be removed from the main queue that this function (and <a class="el" href="UDPC_8h.html#a7527954b63f502479bdd3771df7cf3a4" title="Queues a packet to be sent to the specified peer.">UDPC_queue_send()</a>) uses. The queue that this function refers to does not have an imposed limit as it is implemented as a thread-safe linked list (data is dynamically stored on the heap) and access to this data structure is faster than accessing a connection's internal queue. Also note that this queue holds packets for all connections this context maintains. Thus if one connection has free space, then it may partially remove packets only destined for that connection from the queue this function refers to.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the queue </dd></dl>

</div>
</div>
<a id="a1fb87c1522d353bd9fde4c94ec8454c2" name="a1fb87c1522d353bd9fde4c94ec8454c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb87c1522d353bd9fde4c94ec8454c2">&#9670;&#160;</a></span>UDPC_get_queued_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT unsigned long UDPC_get_queued_size </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>exists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of a connection's queue of queued packets. </p>
<p >Note that a UDPC context holds a queue per established connection that holds a limited amount of packets to send. This function checks a connection's internal queue, but must do so after locking an internal mutex (a call to <a class="el" href="UDPC_8h.html#a68fefba9edca7cd0a81d97ac27c70c0b" title="Updates the context.">UDPC_update()</a> will lock this mutex, regardless of whether or not the context is using threaded update).</p>
<p >If <code>exists</code> is a non-null pointer to an <code>int</code>, and a connection to a peer identified by <code>id</code> exists, then the value of <code>exists</code> will be set to non-zero, otherwise a non-existing peer will set the value of <code>exists</code> to zero.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of a connection's queue </dd></dl>

</div>
</div>
<a id="affa8655a4e7e3475be441060e92213b3" name="affa8655a4e7e3475be441060e92213b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa8655a4e7e3475be441060e92213b3">&#9670;&#160;</a></span>UDPC_get_received()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT <a class="el" href="structUDPC__PacketInfo.html">UDPC_PacketInfo</a> UDPC_get_received </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a received packet from a given UDPC context. </p>
<dl class="section warning"><dt>Warning</dt><dd>The received packet (if valid) must be free'd with a call to <a class="el" href="UDPC_8h.html#ad77c746ea0401664e11bfd76c56e94f5">UDPC_free_PacketInfo_ptr</a> or <a class="el" href="UDPC_8h.html#a68ed6dcb37c6024486fad28ab0bed845">UDPC_free_PacketInfo</a> to avoid a memory leak. </dd></dl>

</div>
</div>
<a id="a8c74f1b9ee0fec610087f83096c9679d" name="a8c74f1b9ee0fec610087f83096c9679d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c74f1b9ee0fec610087f83096c9679d">&#9670;&#160;</a></span>UDPC_get_receiving_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_get_receiving_events </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns non-zero if the UDPC context will record events. </p>
<p >Events that have ocurred can by polled by calling <a class="el" href="UDPC_8h.html#a2c05c6fe89edde1e05ba9b6d8b5f7510" title="Gets a recorded event.">UDPC_get_event()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if receiving events </dd></dl>

</div>
</div>
<a id="a4a555a011e95445ed4a2aa88deb17082" name="a4a555a011e95445ed4a2aa88deb17082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a555a011e95445ed4a2aa88deb17082">&#9670;&#160;</a></span>UDPC_has_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_has_connection </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td>
          <td class="paramname"><em>connectionId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a connection exists to the peer identified by the given <code>connectionId</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
    <tr><td class="paramname">connectionId</td><td>The identifier for a peer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if a connection to the peer exists </dd></dl>

</div>
</div>
<a id="a94660d04e7f9b4d9c51a7b2c67707172" name="a94660d04e7f9b4d9c51a7b2c67707172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94660d04e7f9b4d9c51a7b2c67707172">&#9670;&#160;</a></span>UDPC_has_whitelist_pk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_has_whitelist_pk </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a public key is in the whitelist. </p>
<p >Note that public key verification will not occur if it is not enabled during the call to <a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2" title="Creates an UDPC_HContext that holds state for connections.">UDPC_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the given public key is in the whitelist </dd></dl>

</div>
</div>
<a id="a89dee65fcd5b70d25abbf6d4a3ee59f2" name="a89dee65fcd5b70d25abbf6d4a3ee59f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dee65fcd5b70d25abbf6d4a3ee59f2">&#9670;&#160;</a></span>UDPC_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT UDPC_HContext UDPC_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td>
          <td class="paramname"><em>listenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isClient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isUsingLibsodium</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an UDPC_HContext that holds state for connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listenId</td><td>The addr and port to listen on (contained in a <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a>) </td></tr>
    <tr><td class="paramname">isClient</td><td>Whether or not this instance is a client or a server </td></tr>
    <tr><td class="paramname">isUsingLibsodium</td><td>Set to non-zero if libsodium verification of packets should be enabled (fails if libsodium support was not compiled)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="UDPC_8h.html#ac01480f803b063e2b44794420df0f671" title="Checks if the given UDPC_HContext is valid (successfully initialized)">UDPC_is_valid_context()</a> may be used to check if the context was successfully created.</p>
<dl class="section warning"><dt>Warning</dt><dd>The received UDPC_HContext must be freed with a call to <a class="el" href="UDPC_8h.html#aad0e88866d4c5cb9c0676bc8d7df574e" title="Cleans up the UDPC_HContext.">UDPC_destroy()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A UDPC context </dd></dl>

</div>
</div>
<a id="a614e2a058b89839d53fe9d348a058323" name="a614e2a058b89839d53fe9d348a058323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614e2a058b89839d53fe9d348a058323">&#9670;&#160;</a></span>UDPC_init_threaded_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT UDPC_HContext UDPC_init_threaded_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td>
          <td class="paramname"><em>listenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isClient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isUsingLibsodium</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an UDPC_HContext that holds state for connections that auto-updates via a thread. </p>
<p >By default, the update interval is set to 8 milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listenId</td><td>The addr and port to listen on (contained in a <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a>) </td></tr>
    <tr><td class="paramname">isClient</td><td>Whether or not this instance is a client or a server </td></tr>
    <tr><td class="paramname">isUsingLibsodium</td><td>Set to non-zero if libsodium verification of packets should be enabled (fails if libsodium support was not compiled)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="UDPC_8h.html#ac01480f803b063e2b44794420df0f671" title="Checks if the given UDPC_HContext is valid (successfully initialized)">UDPC_is_valid_context()</a> may be used to check if the context was successfully created.</p>
<dl class="section warning"><dt>Warning</dt><dd>The received UDPC_HContext must be freed with a call to <a class="el" href="UDPC_8h.html#aad0e88866d4c5cb9c0676bc8d7df574e" title="Cleans up the UDPC_HContext.">UDPC_destroy()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A UDPC context </dd></dl>

</div>
</div>
<a id="ab9a5258877ad3084f7d29954be525bd6" name="ab9a5258877ad3084f7d29954be525bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a5258877ad3084f7d29954be525bd6">&#9670;&#160;</a></span>UDPC_init_threaded_update_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT UDPC_HContext UDPC_init_threaded_update_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td>
          <td class="paramname"><em>listenId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isClient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>updateMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isUsingLibsodium</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an UDPC_HContext that holds state for connections that auto-updates via a thread at a specified interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listenId</td><td>The addr and port to listen on (contained in a <a class="el" href="structUDPC__ConnectionId.html" title="Data identifying a peer via addr, port, and scope_id.">UDPC_ConnectionId</a>) </td></tr>
    <tr><td class="paramname">isClient</td><td>Whether or not this instance is a client or a server </td></tr>
    <tr><td class="paramname">updateMS</td><td>The interval to update at in milliseconds (clamped at a minimum of 4 ms and a maximum of 333 ms) </td></tr>
    <tr><td class="paramname">isUsingLibsodium</td><td>Set to non-zero if libsodium verification of packets should be enabled (fails if libsodium support was not compiled)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="UDPC_8h.html#ac01480f803b063e2b44794420df0f671" title="Checks if the given UDPC_HContext is valid (successfully initialized)">UDPC_is_valid_context()</a> may be used to check if the context was successfully created.</p>
<dl class="section warning"><dt>Warning</dt><dd>The received UDPC_HContext must be freed with a call to <a class="el" href="UDPC_8h.html#aad0e88866d4c5cb9c0676bc8d7df574e" title="Cleans up the UDPC_HContext.">UDPC_destroy()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A UDPC context </dd></dl>

</div>
</div>
<a id="ac01480f803b063e2b44794420df0f671" name="ac01480f803b063e2b44794420df0f671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01480f803b063e2b44794420df0f671">&#9670;&#160;</a></span>UDPC_is_valid_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_is_valid_context </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given UDPC_HContext is valid (successfully initialized) </p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the given context is valid </dd></dl>

</div>
</div>
<a id="a7527954b63f502479bdd3771df7cf3a4" name="a7527954b63f502479bdd3771df7cf3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7527954b63f502479bdd3771df7cf3a4">&#9670;&#160;</a></span>UDPC_queue_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT void UDPC_queue_send </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUDPC__ConnectionId.html">UDPC_ConnectionId</a>&#160;</td>
          <td class="paramname"><em>destinationId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isChecked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queues a packet to be sent to the specified peer. </p>
<p >Note that there must already be an established connection with the peer. If a packet is queued for a peer that is not connected, it will be dropped and logged with log-level warning. A client can establish a connection to a server peer via a call to <a class="el" href="UDPC_8h.html#a1192e0307f75feeac888fe5d49976f55" title="Initiate a connection to a server peer.">UDPC_client_initiate_connection()</a> or UDPC_client_initiate_connection_pk(). A server must receive an initiate-connection-packet from a client to establish a connection (sent by previously mentioned UDPC_client_initiate_* functions).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The context to send a packet on </td></tr>
    <tr><td class="paramname">destinationId</td><td>The peer to send a packet to </td></tr>
    <tr><td class="paramname">isChecked</td><td>Set to non-zero if the packet should be re-sent if the peer doesn't receive it </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to data to be sent in a packet </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the data to be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc2d3284e5c45d6cd888154e813a1383" name="abc2d3284e5c45d6cd888154e813a1383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2d3284e5c45d6cd888154e813a1383">&#9670;&#160;</a></span>UDPC_remove_whitelist_pk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_remove_whitelist_pk </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a public key from the whitelist. </p>
<p >Note that public key verification will not occur if it is not enabled during the call to <a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2" title="Creates an UDPC_HContext that holds state for connections.">UDPC_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if a public key was removed </dd></dl>

</div>
</div>
<a id="a32e217a02b2e8ba05568aabfaecbcdcb" name="a32e217a02b2e8ba05568aabfaecbcdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e217a02b2e8ba05568aabfaecbcdcb">&#9670;&#160;</a></span>UDPC_set_accept_new_connections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_set_accept_new_connections </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isAccepting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether or not the UDPC context will accept new connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
    <tr><td class="paramname">isAccepting</td><td>Set to non-zero to accept connections </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous setting (1 if accepting, 0 if not) </dd></dl>

</div>
</div>
<a id="a8d0dbbd258e17844a2f9a0e277789581" name="a8d0dbbd258e17844a2f9a0e277789581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0dbbd258e17844a2f9a0e277789581">&#9670;&#160;</a></span>UDPC_set_auth_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_set_auth_policy </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets how peers are handled regarding public key verification. </p>
<p >If libsodium is enabled and the auth policy is "strict", then peers attempting to connect will be denied if they do not have public key verification enabled. Otherwise if the auth policy is "fallback", then peers will not be denied a connection regardless of whether or not they use public key verification of packets.</p>
<p >Note that public key verification will not occur if it is not enabled during the call to <a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2" title="Creates an UDPC_HContext that holds state for connections.">UDPC_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The previous auth policy (see <a class="el" href="UDPC_8h.html#a228cd7ddf56a4e76e216bc3b80e8bd4a">UDPC_AuthPolicy</a>), or zero on fail </dd></dl>

</div>
</div>
<a id="ad7eb0c77561f84a63dad29388d099fbe" name="ad7eb0c77561f84a63dad29388d099fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7eb0c77561f84a63dad29388d099fbe">&#9670;&#160;</a></span>UDPC_set_libsodium_key_easy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_set_libsodium_key_easy </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>sk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the public/private keys used for packet verification. </p>
<p >This function is almost identical with UDPC_set_libsodium_keys, except it will utilize libsodium to generate the associated public key with the given private key.</p>
<p >Note that public key verification will not occur if it is not enabled during the call to <a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2" title="Creates an UDPC_HContext that holds state for connections.">UDPC_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if keys were successfully set, zero if context is invalid or libsodium is not enabled </dd></dl>

</div>
</div>
<a id="abd0a7d5c0a17cf3351dbe5abf5f70df1" name="abd0a7d5c0a17cf3351dbe5abf5f70df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0a7d5c0a17cf3351dbe5abf5f70df1">&#9670;&#160;</a></span>UDPC_set_libsodium_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_set_libsodium_keys </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>sk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets public/private keys used for packet verification. </p>
<p >If keys are not set and packet verification is enabled, for each new connection new keys will be generated then used. The auto-generated keys used will be unique per connection. Conversely if keys are set, then new connections will use the given keys.</p>
<p >Note that connections established before calling this function will not use the given keys.</p>
<p >Note that public key verification will not occur if it is not enabled during the call to <a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2" title="Creates an UDPC_HContext that holds state for connections.">UDPC_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if keys were successfully set, zero if context is invalid or libsodium is not enabled </dd></dl>

</div>
</div>
<a id="a6c90dc723e67a07bf65c1fc97e526305" name="a6c90dc723e67a07bf65c1fc97e526305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c90dc723e67a07bf65c1fc97e526305">&#9670;&#160;</a></span>UDPC_set_logging_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT UDPC_LoggingType UDPC_set_logging_type </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UDPC_LoggingType&#160;</td>
          <td class="paramname"><em>loggingType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the logging type of the UDPC context. </p>
<p >See UDPC_LoggingType for possible values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
    <tr><td class="paramname">loggingType</td><td>The logging type to set to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previously set logging type </dd></dl>

</div>
</div>
<a id="a0720bec1922660c983b1b3d9f6a5de3a" name="a0720bec1922660c983b1b3d9f6a5de3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0720bec1922660c983b1b3d9f6a5de3a">&#9670;&#160;</a></span>UDPC_set_protocol_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT uint32_t UDPC_set_protocol_id </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the protocol id of the UDPC context. </p>
<p >UDPC uses the protocol id by prefixing every sent packet with it. Other UDPC instances will only accept packets with the same protocol id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
    <tr><td class="paramname">id</td><td>The new id to use as the protocol id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous protocol id of the UDPC context </dd></dl>

</div>
</div>
<a id="a380c91ee395cff22189c7988c3381787" name="a380c91ee395cff22189c7988c3381787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380c91ee395cff22189c7988c3381787">&#9670;&#160;</a></span>UDPC_set_receiving_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_set_receiving_events </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isReceivingEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not UDPC will record events. </p>
<p >Events that have ocurred can by polled by calling <a class="el" href="UDPC_8h.html#a2c05c6fe89edde1e05ba9b6d8b5f7510" title="Gets a recorded event.">UDPC_get_event()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The UDPC context </td></tr>
    <tr><td class="paramname">isReceivingEvents</td><td>Set to non-zero to receive events </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if UDPC was previously receiving events </dd></dl>

</div>
</div>
<a id="a62a5131b90653ccbfc86ad5db4031ba9" name="a62a5131b90653ccbfc86ad5db4031ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a5131b90653ccbfc86ad5db4031ba9">&#9670;&#160;</a></span>UDPC_unset_libsodium_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT int UDPC_unset_libsodium_keys </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes set keys if any used for packet verification. </p>
<p >Note that public key verification will not occur if it is not enabled during the call to <a class="el" href="UDPC_8h.html#a89dee65fcd5b70d25abbf6d4a3ee59f2" title="Creates an UDPC_HContext that holds state for connections.">UDPC_init()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Zero if context is invalid or libsodium is not enabled </dd></dl>

</div>
</div>
<a id="a68fefba9edca7cd0a81d97ac27c70c0b" name="a68fefba9edca7cd0a81d97ac27c70c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fefba9edca7cd0a81d97ac27c70c0b">&#9670;&#160;</a></span>UDPC_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UDPC_EXPORT void UDPC_update </td>
          <td>(</td>
          <td class="paramtype">UDPC_HContext&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the context. </p>
<p >Updating consists of:</p><ul>
<li>Checking if peers have timed out</li>
<li>Handling requests to connect to server peers as a client</li>
<li>Sending packets to connected peers</li>
<li>Receiving packets from connected peers</li>
<li>Calculating round-trip-time (RTT) to peers</li>
<li>Checking if a peer has not received a packet and queuing that packet to be resent (this is done by using an ack)</li>
</ul>
<p >If auto updating was enabled for the context, then there is no need to call this function.</p>
<p >Previously, update would only receive one packet per call to update. Now, each individual call to update will process all packets that have been received but haven't been processed yet. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
